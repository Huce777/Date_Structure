### 3.3 搜索算法

二分法搜索函数的代码：

```python
def binarySearch(target,sortedLyst):
    left=0
    right=len(sortedLyst)-1
    while left<=right:
        midpoint=(left+right)//2
        if target==sortedLyst[midpoint]:
            return midpoint
        elif target<sortedLyst[midpoint]:
            right=midpoint-1
        else:
            left=midpoint+1
    return -1
```



例题：通常来说，查找电话簿中条目的方法与二分搜索并不完全相同，因为使用电话簿的时候， 并不会每次都翻到被搜索的子列表的中点。一般来说，可以根据这个人的姓氏的第一个字母顺序来估算目标可能会在的位置。例如，当查找“ Smith”的电话时，你会首先查看电话簿下半部分的中间，而不是整个电话簿的中间。请对二分搜索算法尝试进行修改， 从而可以在处理名称列表的时候模拟这个策略。它的计算复杂度与标准的二分搜索相比较会更好吗？

```python
def find_by_initial(telephone_book, target):
    # 将目标名称转换为小写，以实现不区分大小写的搜索
    target = target.lower()
    
    # 找到目标首字母在电话簿中的起始位置
    start_index = 0
    while start_index < len(telephone_book) and target[0] > telephone_book[start_index][0]:
        start_index += 1
    
    # 从起始位置开始线性搜索
    for i in range(start_index, len(telephone_book)):
        if telephone_book[i] == target:
            return i  # 返回找到的索引
    return -1  # 如果没有找到，返回-1

# 示例使用
telephone_book = ["Adams", "Baker", "Clark", "Diaz", "Evans", "Foster", "Gonzalez", "Harris", "Irving", "Smith"]
target_name = "Smith"

# 执行搜索
index = find_by_initial(telephone_book, target_name)
if index != -1:
    print(f"Name '{target_name}' found at index {index}.")
else:
    print(f"Name '{target_name}' not found.")
```

### 3.4 基本的排序算法

交换swap函数

```python
def swap(lyst,i,j):
    temp=lyst[i]
    lyst[i]=lyst[j]
    lyst[j]=temp
```



##### 3.4.1 选择排序

```python
def selectionSort(lyst):
    i=0
    while i<len(lyst)-1:
        minIndex=i
        j=i+1
        while j<len(lyst):
            if lyst[j]<lyst[minIndex]:
                minIndex=j
            j+=1
        if minIndex != i:
            swap(lyst,minIndex,i)
        i+=1
            
```

对于比较大的n来说，我们可以选择最高次的项并忽略系数，因此在所有情况下，选择排序的复杂度都是 O(n²)

##### 3.4.2 冒泡排序

其策略是从列表的开头开始，在向后移动到末尾的过程中，对数据进行比较。

```python
def bubbleSort(lyst):
    n=len(lyst)
    while n>1:
        i=1
        while i<n:
            if lyst[i]<lyst[i-1]:
               swap(lyst,i,i-1) 
            i+=1
        n-=1
            
```

改良一下这个冒泡算法

```python
def bubbleSortWithTweak(lyst):
    n=len(lyst)
    while n>1:
        swapped=False
        i=1
        while i<n:
            if lyst[i]<lyst[i-1]:
                swap(lyst,i,i-1)
                swapped=True
                i+=1
            if not swapped:return
            n-=1
```



#### 3.4.3 插入排序

> ● 在第 i 次（其中 i  的范围为 1~ n-1 ）遍历列表时，第 i 个元素插入列表的第 i 个位置处。
>
> ● 在第 i 次遍历列表后，前 i 个元素应该是排好序的。
>
> ● 这个过程类似于很多人组织手里扑克牌的方式。也就是说，在持有前 i-1 张有序扑克牌的情况下，选择第 i 张扑克牌，并
>
> 把它和前面这些扑克牌进行比较，直到找到它的合适位置为止。
>
> ● 和其他排序算法一样插入排序也是由两个循环组成的。外部循环将从位置 1 一直遍历到位置 n-1 。对于这个循环里的每个位置 i 
>
> 应保存这个元素，并从位置 i-1 处开始内部循环。对于这个内部循环里的每个位置 j ，在找到并保存（第 i 个）元素的插入点之前，我们都会把这个元素移动到 j+1 处。

下面是 insertion_Sort 函数的代码

```python
def insertion_Sort(lyst):
    i=1
    while i<len(lyst):
        itemToInsert=lyst[i]
        j=i-1
        while j>=0:
            if itemToInsert<lyst[j]:
                lyst[j+1]=lyst[j]
                j-=1
            else:
                break
        lyst[j+1]=itemToInsert
        i+=1
```

插入排序在最坏情况下复杂度是 O(n²)



##### 问题

###### ***1.列表中如何排序才能使选择排序中元素交换的次数最少？如何排列数据才能让它执行最多的交换次数？***

选择排序是一种简单的排序算法，其基本思想是每次从未排序的序列中找到最小（或最大）的元素，然后将其与未排序序列的第1个元素交换位置，然后从第2个元素开始重新选择最小（或最大）元素，直到排序完成。

###### 使元素交换次数最少的排列

要使选择排序中元素交换的次数最少，理想的情况是列表已经接近有序。具体来说：

1. **最佳情况**：列表已经完全有序。在这种情况下，选择排序只需要进行 \(n-1\) 次比较（每次选择最小元素），但不需要进行任何交换。因此，交换次数为0。

2. **接近最佳情况**：列表中只有一个元素是未在正确位置上的。这种情况下，选择排序需要进行 \(n-1\) 次比较，但只需要进行1次交换。

###### 使元素交换次数最多的排列

要使选择排序中元素交换的次数最多，理想的情况是列表完全逆序。具体来说：

1. **最坏情况**：列表完全逆序。在这种情况下，选择排序需要进行 \(n-1\) 次比较，并且每次比较后都需要进行一次交换，因此交换次数为 \(n-1\)。

2. **接近最坏情况**：列表中大部分元素都未在正确位置上，且每次选择的最小元素都位于列表的末尾。这种情况下，选择排序的交换次数接近 \(n-1\)。

###### 具体例子

- **最少交换次数的例子**：
  ```plaintext
  1 2 3 4 5
  ```
  这里不需要交换任何元素。

- **最多交换次数的例子**：
  ```plaintext
  5 4 3 2 1
  ```
  这里需要交换4次，每次交换的元素分别是5、4、3、2。

###### 总结

- **最少交换次数**：选择排序的最少交换次数发生在列表已经有序或接近有序的情况下。
- **最多交换次数**：选择排序的最多交换次数发生在列表完全逆序的情况下。

选择排序的交换次数与列表的初始排列直接相关，因此通过控制列表的初始排列，可以控制选择排序的交换次数。



##### ***2.请说明数据交换的次数在分析选择排序和冒泡排序时所起的作用。数据对象的规模在它们之间发挥着什么作用（如果有作用）？***

在选择排序和冒泡排序中，数据交换的次数是衡量算法效率的关键指标之一。以下是它们在分析这两种排序算法时所起的作用，以及数据对象的规模如何影响它们：

###### 选择排序

1. **交换次数**：
   - 选择排序的交换次数与数据的初始顺序无关。它始终需要进行 \(n-1\) 次交换，其中 \(n\) 是列表的长度。
   - 每次迭代中，选择排序会找到未排序部分的最小（或最大）元素，并将其与当前位置的元素交换。

2. **数据交换次数的作用**：
   - 选择排序的效率主要取决于交换次数，因为每次交换操作涉及数据移动，这是计算成本较高的操作。
   - 尽管选择排序的交换次数固定，但其比较次数较多，因此总体效率较低。

3. **数据对象的规模**：
   - 数据对象的规模对选择排序的影响较小。选择排序的时间复杂度始终为 \(O(n^2)\)，无论数据规模大小。
   - 选择排序的空间复杂度为 \(O(1)\)，因为它是原地排序算法，不需要额外的存储空间。

###### 冒泡排序

1. **交换次数**：
   - 冒泡排序的交换次数与数据的初始顺序密切相关。在最好的情况下（列表已经有序），交换次数为0；在最坏的情况下（列表完全逆序），交换次数为 n*(n-1)/2  。
   - 冒泡排序通过相邻元素的比较和交换来排序，每次迭代中，未排序部分的最后一个元素会“冒泡”到其正确的位置。

2. **数据交换次数的作用**：
   - 冒泡排序的效率主要取决于交换次数和比较次数。交换次数直接影响算法的执行时间。
   - 冒泡排序在最好的情况下非常高效，但在最坏的情况下效率较低。

3. **数据对象的规模**：
   - 数据对象的规模对冒泡排序的影响较大。在小规模数据中，冒泡排序的效率相对较高，因为交换和比较次数较少。
   - 随着数据规模的增加，冒泡排序的时间复杂度 \(O(n^2)\) 会导致其效率显著下降。

###### 总结

- **选择排序**：交换次数固定，比较次数较多，效率较低且与数据的初始顺序无关。数据对象的规模对其影响较小。
- **冒泡排序**：交换次数与数据的初始顺序有关，效率在最好和最坏情况下差异较大。数据对象的规模对其影响较大，特别是在大规模数据中效率较低。

在选择排序和冒泡排序中，数据交换的次数直接影响算法的执行时间和效率。理解这些因素对于优化算法和选择合适的排序方法至关重要。



##### ***3.请说明为什么插入排序在部分有序的列表上能很好地工作？***

插入排序是一种简单直观的排序算法，它在部分有序的列表上表现良好，主要原因如下：

1. **工作原理**：
   - 插入排序通过构建有序序列来排序整个列表。算法从第一个元素开始，认为这个元素是有序的，然后逐个将剩余元素插入到已排序的序列中。

2. **局部有序的利用**：
   - 当列表中已经存在一些有序的子序列时，插入排序可以利用这些局部的有序性，减少不必要的比较和移动操作。这是因为在插入排序过程中，如果新元素的值大于或等于当前比较的元素值，那么后续的元素不需要再进行比较和移动。

3. **减少比较次数**：
   - 在部分有序的列表中，插入排序的比较次数通常会减少。因为插入排序的比较次数取决于元素需要向前移动的距离，而在部分有序的列表中，新插入的元素往往不需要移动很远。

4. **减少移动次数**：
   - 插入排序的移动次数也与列表的有序程度有关。在部分有序的列表中，新插入的元素可能只需要移动较少的位置，甚至不需要移动，从而减少了移动操作的次数。

5. **稳定性**：
   - 插入排序是一种稳定的排序算法，这意味着相等的元素在排序后会保持它们原有的顺序。这种稳定性在部分有序的列表中尤其有用，因为它可以保持原有有序子序列的顺序。

6. **自适应性**：
   - 插入排序具有自适应性，即它可以根据数据的初始状态调整其行为。如果数据已经部分有序，插入排序的性能会显著提高。

7. **原地排序**：
   - 插入排序是原地排序算法，不需要额外的存储空间，这使得它在处理部分有序的列表时更加高效。

8. **时间复杂度**：
   - 在最好的情况下（列表已经完全有序），插入排序的时间复杂度为 \(O(n)\)，其中 \(n\) 是列表的长度。在部分有序的列表中，尽管时间复杂度仍为 \(O(n^2)\)，但实际执行时的比较和移动次数会显著减少。

###### 总结

插入排序在部分有序的列表上表现良好，主要是因为它能够利用列表中已有的有序子序列，减少比较和移动操作的次数。这种算法的自适应性和稳定性使其在处理部分有序数据时特别有效。尽管其平均时间复杂度为 \(O(n^2)\)，但在实际应用中，特别是在数据部分有序的情况下，插入排序可以提供比理论复杂度更好的性能。
