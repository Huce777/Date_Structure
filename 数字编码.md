#### *数字编码*

##### 原码、反码和补码

###### 数字是以 “补码” 的形式存储在计算机中的。在分析这样做的原因之前，首先给出这三者的定义。

●  **原码** ：我们将数字的二进制表示的最高位视为符号位，其中 0 表示正数，1 表示负数，其余位表示数字的值。

●  **反码**  ：正数的反码与其原码相同，负数的反码是对其原码除符号位外的所有位取反。

●  **补码**  ：正数的补码与其原码相同，负数的补码是在其反码党的基础上加 1 。

![原码、反码与补码之间的相互转换](https://www.hello-algo.com/chapter_data_structure/number_encoding.assets/1s_2s_complement.png)

原码（sign-magnitude）虽然最直观，但存在一些局限性。一方面，**负数的原码不能直接用于运算**。例如在原码下计算 1+ ( -2 ) ，得到的结果是 -3 ，这显然是不对的。

​			1  +（ - 2 ）

​			----> 0000 0001 + 1000 0010

​			===  1000 0011

​			-----> - 3

为了解决此问题，计算机引入了**反码**。如果我们先将原码转换为反码，并在反码下计算 1+(-2) ,最后将结果从反码转换回原码，则可得到正确结果 -1 。

​			1 +（ - 2 ）

​			---> 0000 0001（原码）+   1000 0010（原码）

​			==   0000 0001（反码）+   1111 1101（反码）

​			==    1111 1110（反码）

​			==   1000 0001（原码）

​			---->  -1

另一方面，**数字零的原码有 +0 和 -0 两种表示方式。**这意味着数字零对应两个不同的二进制编码，这可能会带来歧义。如果没有区分，可能会导致判断结果出错。

   + 0 -----> 0000 0000
   + -0 ----> 1000 0000

与原码一样，反码也存在正负零歧义问题，因此计算机进一步引入了 **补码** 。

​		- 0 -----> 1000 0000（原码）

​		     ====  1111 1111（反码）

​		     ====  1 0000 0000（补码）

在负零的反码基础上加 1 会产生进位，但 `byte` 类型的长度只有 8 位，因此溢出到第 9 位的 1 会被舍弃。也就是说，**负零的补码为 0000 0000 ，与正零的补码相同**。这意味着在补码表示中只存在一个零，正负零歧义从而得到解决。

还剩最后一个疑惑：`byte` 类型的取值范围是 [−128,127] ，多出来的一个负数 −128 是如何得到的呢？我们注意到，区间 [−127,+127] 内的所有整数都有对应的原码、反码和补码，并且原码和补码之间可以互相转换。

然而，**补码 1000 0000 是一个例外，它并没有对应的原码**。根据转换方法，我们得到该补码的原码为 0000 0000 。这显然是矛盾的，因为该原码表示数字 0 ，它的补码应该是自身。计算机规定这个特殊的补码 1000 0000 代表 −128 。实际上，(−1)+(−127) 在补码下的计算结果就是 −128 。

​		（ - 127 ）+（ - 1 ）

​		---> 1111 1111（原码）+  1000 0001（原码）

​		==  1000 0000（反码）+   1111 1110（反码）

​		==  1000 0001（补码）+    1111 1111（补码）

​		==  1000 0000（补码）

​		--->  - 128

你可能已经发现了，上述所有计算都是加法运算。这暗示着一个重要事实：**计算机内部的硬件电路主要是基于加法运算设计的**。这是因为加法运算相对于其他运算（比如乘法、除法和减法）来说，硬件实现起来更简单，更容易进行并行化处理，运算速度更快。

请注意，这并不意味着计算机只能做加法。**通过将加法与一些基本逻辑运算结合，计算机能够实现各种其他的数学运算**。例如，计算减法 a−b 可以转换为计算加法 a+(−b) ；计算乘法和除法可以转换为计算多次加法或减法。

现在我们可以总结出计算机使用补码的原因：基于补码表示，计算机可以用同样的电路和操作来处理正数和负数的加法，不需要设计特殊的硬件电路来处理减法，并且无须特别处理正负零的歧义问题。这大大简化了硬件设计，提高了运算效率。

补码的设计非常精妙，因篇幅关系我们就先介绍到这里，建议有兴趣的读者进一步深入了解。

##### 浮点数编码

![IEEE 754 标准下的 float 的计算示例](https://www.hello-algo.com/chapter_data_structure/number_encoding.assets/ieee_754_float.png)